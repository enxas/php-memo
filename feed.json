{
    "version": "https://jsonfeed.org/version/1",
    "title": "PHPMemo",
    "description": "",
    "home_page_url": "https://phpmemo.com",
    "feed_url": "https://phpmemo.com/feed.json",
    "user_comment": "",
    "author": {
        "name": "Enxas"
    },
    "items": [
        {
            "id": "https://phpmemo.com/fastest-way-to-insert-one-million-records-to-mysql-database.html",
            "url": "https://phpmemo.com/fastest-way-to-insert-one-million-records-to-mysql-database.html",
            "title": "How to Insert 1 Million Records Lightning-Fast",
            "summary": "When working with large datasets, inserting a massive number of records into a database can become painfully slow. Fortunately, MySQL provides an optimized solution: the&hellip;",
            "content_html": "<p>When working with large datasets, inserting a massive number of records into a database can become painfully slow. Fortunately, MySQL provides an optimized solution: the <code class=\"bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.3rem] px-1 py-px text-[0.9rem]\">LOAD DATA</code> statement. This method is significantly faster than traditional insertion methods, making it ideal for bulk data imports.</p>\n<p>In this tutorial, I'll demonstrate how to generate, export, and import one million records into a MySQL database using Laravel. The principles discussed can be applied to various PHP applications.</p>\n<h2 class=\"font-600 text-xl font-bold\">Creating the Database Schema</h2>\n<p class=\"whitespace-pre-wrap break-words\">Let's start by defining a schema for a <code class=\"bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.3rem] px-1 py-px text-[0.9rem]\">shops</code> table:</p>\n<pre class=\"language-php\"><code>Schema::create('shops', function (Blueprint $table) {\n\t$table-&gt;id();\n\t$table-&gt;string('name');\n\t$table-&gt;text('description');\n\t$table-&gt;string('email')-&gt;unique();\n\t$table-&gt;date('established_date');\n\t$table-&gt;time('opening_time'); \n\t$table-&gt;decimal('rating', 3, 2);\n\t$table-&gt;boolean('is_open');\n});</code></pre>\n<h2 class=\"font-600 text-xl font-bold\">Generating Test Data</h2>\n<p class=\"whitespace-pre-wrap break-words\">To populate our database, we'll use the Faker library to generate realistic sample data:</p>\n<pre class=\"language-php\"><code>$faker = \\Faker\\Factory::create();\n\n$shops = [];\n\nfor ($i = 0; $i &lt; 1_000_000; $i++) {\n\t$shops[] = [\n\t\t'name' =&gt; $faker-&gt;company,\n\t\t'description' =&gt; $faker-&gt;paragraph,\n\t\t'email' =&gt; $faker-&gt;unique()-&gt;safeEmail,\n\t\t'established_date' =&gt; $faker-&gt;date,\n\t\t'opening_time' =&gt; $faker-&gt;time,\n\t\t'rating' =&gt; $faker-&gt;randomFloat(2, 0, 5),\n\t\t'is_open' =&gt; $faker-&gt;boolean,\n\t];\n\n\t// insert in batches to avoid memory issues\n\tif ($i % 1000 === 0) {\n\t\tDB::table('shops')-&gt;insert($shops);\n\t\t$shops = [];\n\t}\n}\n\n// insert any remaining records\nif (!empty($shops)) {\n\tDB::table('shops')-&gt;insert($shops);\n}</code></pre>\n<h2 class=\"font-600 text-xl font-bold\">Exporting Data to CSV</h2>\n<p class=\"whitespace-pre-wrap break-words\">Next, we'll export the records to a CSV file:</p>\n<pre class=\"language-php\"><code>$filePath = storage_path('app/shops.csv');\n\t\t\n$file = fopen($filePath, 'w');\n\nDB::table('shops')-&gt;chunkById(10_000, function ($shops) use ($file) {\n\tforeach ($shops as $shop) {\n\t\t$row = [\n\t\t\t$shop-&gt;id, \n\t\t\t$shop-&gt;name, \n\t\t\t$shop-&gt;description, \n\t\t\t$shop-&gt;email, \n\t\t\t$shop-&gt;established_date, \n\t\t\t$shop-&gt;opening_time, \n\t\t\t$shop-&gt;rating, \n\t\t\t$shop-&gt;is_open,\n\t\t];\n\n\t\tfputcsv($file, $row, eol: \"\\n\");\n\t}\n});\n\nfclose($file);</code></pre>\n<p>Now that we have all of our data in a CSV file, we can clean the <code>shops</code> table:</p>\n<pre class=\"language-sql\"><code>TRUNCATE TABLE shops;</code></pre>\n<h2>Importing data (slow)</h2>\n<p>This is the standard approach for writing code to import data:</p>\n<pre class=\"language-php\"><code>DB::statement('ALTER TABLE shops DISABLE KEYS');\n\n$handle = fopen(storage_path('app/shops.csv'), 'r');\n$shops = [];\n\nwhile (($data = fgetcsv($handle, 500, ',')) !== false) {\n\t$shops[] = [\n\t\t'id' =&gt; $data[0],\n\t\t'name' =&gt; $data[1],\n\t\t'description' =&gt; $data[2],\n\t\t'email' =&gt; $data[3],\n\t\t'established_date' =&gt; $data[4],\n\t\t'opening_time' =&gt; $data[5],\n\t\t'rating' =&gt; $data[6],\n\t\t'is_open' =&gt; $data[7],\n\t];\n\n\t// insert in batches to avoid memory issues\n\tif (count($shops) % 1000 === 0) {\n\t\tDB::table('shops')-&gt;insert($shops);\n\t\t$shops = [];\n\t}\n}\n\n// insert any remaining records\nif (count($shops) &gt; 0) {\n\tDB::table('shops')-&gt;insert($shops);\n}\n\nfclose($handle);\n\nDB::statement('ALTER TABLE shops ENABLE KEYS');</code></pre>\n<p>The issue with this approach is that it’s slow. It took approximately 7 minutes and 40 seconds to import all the data.</p>\n<h2 class=\"font-600 text-xl font-bold\">Preparing for Import</h2>\n<p class=\"whitespace-pre-wrap break-words\">Before doing <code>LOAD DATA</code> import, we need to make a few configurations:</p>\n<h3 class=\"font-600 text-lg font-bold\">1. Check and Enable local_infile</h3>\n<p class=\"whitespace-pre-wrap break-words\">First, verify if the <code class=\"bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.3rem] px-1 py-px text-[0.9rem]\">local_infile</code> feature is enabled in MySQL database:</p>\n<pre class=\"language-sql\"><code>SHOW GLOBAL VARIABLES LIKE 'local_infile';</code></pre>\n<p>If it's OFF, enable it:</p>\n<pre class=\"language-sql\"><code>SET GLOBAL local_infile = TRUE;</code></pre>\n<h3 class=\"font-600 text-lg font-bold\">2. Configure Laravel Database Connection</h3>\n<p class=\"whitespace-pre-wrap break-words\">In <code class=\"bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.3rem] px-1 py-px text-[0.9rem]\">config/database.php</code>, add the <code class=\"bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.3rem] px-1 py-px text-[0.9rem]\">local_infile</code> option:</p>\n<div>\n<pre class=\"language-apacheconf\"><code>'mysql' =&gt; [\n    // ... other configurations\n    'options' =&gt; extension_loaded('pdo_mysql') ? array_filter([\n        PDO::MYSQL_ATTR_LOCAL_INFILE =&gt; true,\n    ]) : [],\n],</code></pre>\n<h2 class=\"font-600 text-xl font-bold\">Importing Data Using LOAD DATA (fast)</h2>\n<p class=\"whitespace-pre-wrap break-words\">Now we're ready to import the data efficiently:</p>\n<pre class=\"language-php\"><code>$filePath = storage_path('app/shops.csv');\n\nDB::statement('ALTER TABLE shops DISABLE KEYS');\n\nDB::unprepared(\"\n    LOAD DATA LOCAL INFILE '$filePath' \n    INTO TABLE shops \n    FIELDS TERMINATED BY ',' \n    OPTIONALLY ENCLOSED BY '\\\"' \n    LINES TERMINATED BY '\\\\n' \n    IGNORE 0 ROWS \n    (id, name, description, email, established_date, opening_time, rating, is_open)\n\");\n\nDB::statement('ALTER TABLE shops ENABLE KEYS');</code></pre>\n<h2 class=\"font-600 text-xl font-bold\">Performance Insights</h2>\n<p class=\"whitespace-pre-wrap break-words\">Wit this approach, importing a 233 MB CSV file with one million records took approximately 40 seconds—a remarkable improvement over traditional insertion methods.</p>\n<h2>Some Considerations</h2>\n<ul>\n<li class=\"whitespace-normal break-words\">Disable keys before bulk import and re-enable them after import.</li>\n<li>For security reasons <code>local_infile</code> should be disabled when it's not in use.</li>\n<li>Large CSV file imports slow down over time, so it's better to import two 100-million record files than one 200-million record file.</li>\n</ul>\n</div>",
            "author": {
                "name": "Enxas"
            },
            "tags": [
                   "PHP",
                   "MySQL",
                   "Laravel"
            ],
            "date_published": "2024-12-12T21:49:53+02:00",
            "date_modified": "2024-12-14T12:22:41+02:00"
        },
        {
            "id": "https://phpmemo.com/identifying-and-logging-duplicate-queries-in-laravel-requests.html",
            "url": "https://phpmemo.com/identifying-and-logging-duplicate-queries-in-laravel-requests.html",
            "title": "Identifying and Logging Duplicate Queries in Laravel Requests",
            "summary": "When developing your Laravel application, you want to avoid unnecessarily making duplicate requests for performance reasons. However, it can be challenging to identify how many&hellip;",
            "content_html": "<p>When developing your Laravel application, you want to avoid unnecessarily making duplicate requests for performance reasons. However, it can be challenging to identify how many and which queries are duplicates. Here's a helper script that logs duplicate queries to the <code>laravel.log</code> file and records how many times they were executed.</p>\n<p>Place this code in the <code>boot()</code> method of your <code>AppServiceProvider.php</code> file, then check your <code>laravel.log</code> file. This code uses Redis, but you can swap it to Cache.</p>\n<pre class=\"language-php\"><code>Redis::del('QueryStats');\n\nEvent::listen(QueryExecuted::class, function (QueryExecuted $event) {\n\tRedis::rpush('QueryStats', json_encode([\n\t\t'connection' =&gt; $event-&gt;connectionName,\n\t\t'query' =&gt; $event-&gt;sql,\n\t\t'bindings' =&gt; $event-&gt;bindings,\n\t\t'time' =&gt; $event-&gt;time,\n\t\t'trace' =&gt; collect(debug_backtrace())-&gt;map(function ($trace) {\n\t\t\treturn Arr::only($trace, ['file', 'line', 'class', 'method']);\n\t\t})-&gt;toArray(),\n\t]));\n});\n\n$this-&gt;app-&gt;terminating(function () {\n\t$stats = Redis::lrange('QueryStats', 0, -1);\n\n\t$data = [\n\t\t'query_count' =&gt; 0,\n\t];\n\n\tforeach ($stats as $stat) {\n\t\t$queryStat = json_decode($stat);\n\n\t\tif (str_contains($queryStat-&gt;query, 'telescope_')) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!isset($data[$queryStat-&gt;query])) {\n\t\t\t$data[$queryStat-&gt;query] = 1;\n\t\t} else {\n\t\t\t$data[$queryStat-&gt;query] += 1;\n\t\t}\n\n\t\t$data['query_count'] += 1;\n\n\t\tarsort($data);\n\t}\n\n\tLog::info($data);\n});</code></pre>",
            "author": {
                "name": "Enxas"
            },
            "tags": [
                   "PHP",
                   "Laravel",
                   "Debug"
            ],
            "date_published": "2024-12-10T21:01:22+02:00",
            "date_modified": "2024-12-10T21:02:36+02:00"
        },
        {
            "id": "https://phpmemo.com/most-popular-design-patterns.html",
            "url": "https://phpmemo.com/most-popular-design-patterns.html",
            "title": "Most Popular Design Patterns",
            "summary": "Throughout my experience, these design patterns have stood out to me. It's useful for creating loose coupling between components, and enabling a one-to-many dependency between&hellip;",
            "content_html": "<div>\n<p>Throughout my experience, these design patterns have stood out to me.</p>\n<h2>Observer Pattern</h2>\n</div>\n<p>It's useful for creating loose coupling between components, and enabling a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically without them needing to constantly poll for changes.</p>\n<pre class=\"language-php\"><code>enum ProductEvent\n{\n\tcase Available;\n\tcase Discounted;\n}\n\ninterface ProductObserver\n{\n\tfunction notify(Product $product, ProductEvent $event): void;\n}\n\nclass Product\n{\n\t/**\n\t * @var ProductObserver[]\n\t */\n\tprivate $observers = [];\n\n\n\tfunction changeAvailability()\n\t{\n\t\t// change availability\n\n\t\t$this-&gt;notify(ProductEvent::Available);\n\t}\n\n\tfunction setDiscount()\n\t{\n\t\t// set discount\n\n\t\t$this-&gt;notify(ProductEvent::Discounted);\n\t}\n\n\t// ----------- event code -----------\n\n\tfunction attach(ProductObserver $observer)\n\t{\n\t\t$this-&gt;observers[spl_object_hash($observer)] = $observer;\n\t}\n\n\tfunction detach(ProductObserver $observer)\n\t{\n\t\tunset($this-&gt;observers[spl_object_hash($observer)]);\n\t}\n\n\tfunction notify(ProductEvent $event)\n\t{\n\t\tforeach ($this-&gt;observers as $observer) {\n\t\t\t$observer-&gt;notify($this, $event);\n\t\t}\n\t}\n}\n\nclass Emailer implements ProductObserver\n{\n\tfunction notify(Product $product, ProductEvent $event): void\n\t{\n\t\tmatch ($event) {\n\t\t\tProductEvent::Available =&gt; $this-&gt;sendProductAvailableEmail(),\n\t\t\tProductEvent::Discounted =&gt; $this-&gt;sendProductDiscountedEmail(),\n\t\t};\n\t}\n\n\tfunction sendProductAvailableEmail()\n\t{\n\t\techo 'Sending product available email' . PHP_EOL;\n\t}\n\n\tfunction sendProductDiscountedEmail()\n\t{\n\t\techo 'Sending product discounted email' . PHP_EOL;\n\t}\n}\n\nclass Logger implements ProductObserver\n{\n\tfunction notify(Product $product, ProductEvent $event): void\n\t{\n\t\techo 'Product updated: ' . $event-&gt;name  . PHP_EOL;\n\t}\n}\n\n$product = new Product;\n$logger = new Logger;\n$emailer = new Emailer;\n\n$product-&gt;attach($logger);\n$product-&gt;attach($emailer);\n\n$product-&gt;changeAvailability();\n$product-&gt;setDiscount();\n\n$product-&gt;detach($emailer);\n\n$product-&gt;changeAvailability();\n$product-&gt;setDiscount();</code></pre>\n<div>\n<h2>Facade Pattern</h2>\n<p>The Facade design pattern provides a simplified, unified interface to a complex subsystem, hiding intricate interactions and making the system easier to use and modify. It reduces complexity by offering a clean, high-level entry point that encapsulates the underlying implementation details, promoting loose coupling and easier switching of inner implementations.</p>\n<pre class=\"language-php\"><code>interface Logger\n{\n\tpublic function log(string $text): void;\n}\n\nclass FileLogger implements Logger\n{\n\tpublic function log(string $text): void\n\t{\n\t\t// log to a file\n\t}\n}\n\nclass DatabaseLogger implements Logger\n{\n\tpublic function log(string $text): void\n\t{\n\t\t// log to a database\n\t}\n}\n\nclass Log\n{\n\tpublic static function info(string $logger, string $text): void\n\t{\n\t\t(new $logger)-&gt;log($text);\n\t}\n}\n\nLog::info(DatabaseLogger::class, 'hello');</code></pre>\n<div>\n<h2>Strategy Pattern</h2>\n<div>\n<div>A way to switch implementations (strategies) for objects that perform the same actions differently.</div>\n<ul>\n<li>When some action could be done in different ways, for example payment can be processed by different payment providers.</li>\n<li>When passing a bunch of flags to a function as parameter to configure different behaviors just pass a different behavior (strategy).</li>\n</ul>\n<div>\n<pre class=\"language-php\"><code>interface PaymentStrategyInterface\n{\n\tpublic function doPayment($amount): void;\n}\n\nclass PaymentService\n{\n\tpublic function __construct(private PaymentStrategyInterface $strategy) {}\n\n\tpublic function process(int $amount): void\n\t{\n\t\t$this-&gt;strategy-&gt;doPayment($amount);\n\t}\n}\n\nclass CreditCardPaymentStrategy implements PaymentStrategyInterface\n{\n\tpublic function doPayment($amount): void\n\t{\n\t\t// do credit card stuff\n\t}\n}\n\nclass PaypalPaymentStrategy implements PaymentStrategyInterface\n{\n\tpublic function doPayment($amount): void\n\t{\n\t\t// do paypal stuff\n\t}\n}\n\n$ccStrategy = new CreditCardPaymentStrategy();\n$paypalStrategy = new PaypalPaymentStrategy();\n\n// pass in whichever\n$paymentService = new PaymentService($ccStrategy);\n\n// OR you can create Context, which encapsulates currently selected strategy\n\nclass PaymentStrategyContext\n{\n\tprivate PaymentStrategyInterface $strategy;\n\n\tpublic function __construct(string $paymentMethod)\n\t{\n\t\t$this-&gt;strategy = match ($paymentMethod) {\n\t\t\t'paypal' =&gt; new PaypalPaymentStrategy(),\n\t\t\t'credit_card' =&gt; new CreditCardPaymentStrategy(),\n\t\t\tdefault =&gt; throw new \\InvalidArgumentException('Unknown payment method'),\n\t\t};\n\t}\n\n\tpublic function doPayment($amount)\n\t{\n\t\treturn $this-&gt;strategy-&gt;doPayment($amount);\n\t}\n}\n\n$strategyService = new PaymentStrategyContext($request-&gt;payment_method);\n$strategyService-&gt;doPayment($amount);</code></pre>\n<div>\n<h2>Builder Pattern</h2>\n<p class=\"whitespace-pre-wrap break-words\">The Builder pattern provides a flexible and readable way to construct complex objects step by step, separating the construction of a complex object from its representation. It allows you to create different variations of an object using the same construction process, which is particularly useful when an object has multiple optional parameters or configuration possibilities.</p>\n<ul class=\"-mt-1 [li&gt;&amp;]:mt-2 list-disc space-y-2 pl-8\">\n<li class=\"whitespace-normal break-words\">Creating objects with numerous constructor parameters</li>\n<li class=\"whitespace-normal break-words\">Implementing configurable object creation where the configuration may evolve</li>\n<li class=\"whitespace-normal break-words\">Providing a clean, fluent interface for object initialization</li>\n<li class=\"whitespace-normal break-words\">Ensuring consistent object creation across different configurations</li>\n</ul>\n<pre class=\"language-php\"><code>class Book\n{\n\tprivate $id;\n\tprivate $title;\n\tprivate $price;\n\tprivate $author;\n\n\tpublic function __construct(BookBuilder $builder)\n\t{\n\t\t$this-&gt;id = $builder-&gt;getId();\n\t\t$this-&gt;title = $builder-&gt;getTitle();\n\t\t$this-&gt;price = $builder-&gt;getPrice();\n\t\t$this-&gt;author = $builder-&gt;getAuthor();\n\t}\n}\n\nclass BookBuilder\n{\n\tprivate $id;\n\tprivate $title;\n\tprivate $price;\n\tprivate $author;\n\n\tpublic function setId($id): self\n\t{\n\t\t$this-&gt;id = $id;\n\t\treturn $this;\n\t}\n\n\tpublic function setTitle($title): self\n\t{\n\t\t$this-&gt;title = $title;\n\t\treturn $this;\n\t}\n\n\tpublic function setPrice($price): self\n\t{\n\t\t$this-&gt;price = $price;\n\t\treturn $this;\n\t}\n\n\tpublic function setAuthor($author): self\n\t{\n\t\t$this-&gt;author = $author;\n\t\treturn $this;\n\t}\n\n\tpublic function build()\n\t{\n\t\tif (empty($this-&gt;id) || empty($this-&gt;title) || empty($this-&gt;price)  || empty($this-&gt;author)) {\n\t\t\tthrow new \\Exception('Required fields missing');\n\t\t}\n\n\t\treturn new Book($this);\n\t}\n}\n\n$productBuilder = new BookBuilder();\n$product = $productBuilder\n\t-&gt;setId(101)\n\t-&gt;setTitle('Title')\n\t-&gt;setPrice(123.99)\n\t-&gt;setAuthor('author')\n\t-&gt;build();</code></pre>\n<div>\n<h2>Factory Pattern</h2>\n<p>Uniform way to create objects in one step. Factory is about \"what\" type of object to create.</p>\n<pre class=\"language-php\"><code>interface Animal\n{\n\tpublic function speak(): string;\n}\n\nclass Dog implements Animal\n{\n\tpublic function speak(): string\n\t{\n\t\treturn 'Woof!';\n\t}\n}\n\nclass Cat implements Animal\n{\n\tpublic function speak(): string\n\t{\n\t\treturn 'Meow!';\n\t}\n}\n\nclass AnimalFactory\n{\n\tpublic function createAnimal(string $type): Animal\n\t{\n\t\treturn match ($type) {\n\t\t\t'dog' =&gt; new Dog(),\n\t\t\t'cat' =&gt; new Cat(),\n\t\t\tdefault =&gt; throw new \\Exception('Unknown animal')\n\t\t};\n\t}\n}\n\n// Example usage\n$factory = new AnimalFactory();\n$dog = $factory-&gt;createAnimal('dog');\necho $dog-&gt;speak(); </code></pre>\n<div>\n<h2>Adapter Pattern</h2>\n<p>The Adapter pattern allows incompatible interfaces to work together by creating a wrapper that converts the interface of one class into another interface that clients expect. It enables seamless integration between classes with different interfaces, allowing you to make existing classes work with others without modifying their source code. This pattern is particularly useful when migrating between libraries, integrating third-party components, or bridging legacy and modern systems.</p>\n<pre class=\"language-php\"><code>// target interface\ninterface BookInterface\n{\n\tpublic function read();\n}\n\n// existing class with an incompatible interface\nclass EBook\n{\n\tpublic function displayContent()\n\t{\n\t\techo 'Displaying e-book content';\n\t}\n}\n\nclass EBookAdapter implements BookInterface\n{\n\tprivate $eBook;\n\n\tpublic function __construct(EBook $eBook)\n\t{\n\t\t$this-&gt;eBook = $eBook;\n\t}\n\n\tpublic function read()\n\t{\n\t\t$this-&gt;eBook-&gt;displayContent();\n\t}\n}\n\nclass Library\n{\n\tpublic function readBook(BookInterface $book)\n\t{\n\t\t$book-&gt;read();\n\t}\n}\n\n// Usage\n$eBook = new EBook();\n$eBookAdapter = new EBookAdapter($eBook);\n\n$library = new Library();\n$library-&gt;readBook($eBookAdapter);</code></pre>\n<div>\n<h2>Decorator Pattern</h2>\n<p>The Decorator pattern dynamically adds behaviors to an object by wrapping it with additional functionality, allowing flexible and granular extension without inheritance. It enables runtime modification of individual objects' capabilities without affecting other instances of the same class.</p>\n<pre class=\"language-php\"><code>interface Pie\n{\n\tpublic function makePie(): string;\n\tpublic function getPrice(): int;\n}\n\nclass BasicPie implements Pie\n{\n\tprivate const PRICE = 1;\n\n\tpublic function makePie(): string\n\t{\n\t\treturn 'basic pie';\n\t}\n\n\tpublic function getPrice(): int\n\t{\n\t\treturn self::PRICE;\n\t}\n}\n\nabstract class BasicPieDecorator implements Pie\n{\n\tpublic function __construct(protected Pie $basicPie) {}\n\n\tabstract public function makePie(): string;\n\tabstract public function getPrice(): int;\n}\n\nclass ApplePie extends BasicPieDecorator\n{\n\tprivate const PRICE = 2;\n\n\tpublic function makePie(): string\n\t{\n\t\treturn 'apple pie';\n\t}\n\n\tpublic function getPrice(): int\n\t{\n\t\treturn $this-&gt;basicPie-&gt;getPrice() + self::PRICE;\n\t}\n}\n\nclass PumpkinPie extends BasicPieDecorator\n{\n\tprivate const PRICE = 3;\n\n\tpublic function makePie(): string\n\t{\n\t\treturn 'pumpkin pie';\n\t}\n\n\tpublic function getPrice(): int\n\t{\n\t\treturn $this-&gt;basicPie-&gt;getPrice() + self::PRICE;\n\t}\n}\n\n$basicPie = new BasicPie();\n$basicPie-&gt;getPrice();\n\n$applePie = new ApplePie($basicPie);\n$applePie-&gt;getPrice();\n\n$pumpkinPie = new PumpkinPie($basicPie);\n$pumpkinPie-&gt;getPrice();</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>",
            "author": {
                "name": "Enxas"
            },
            "tags": [
                   "PHP",
                   "Design Patterns"
            ],
            "date_published": "2024-12-08T16:42:42+02:00",
            "date_modified": "2024-12-08T17:05:37+02:00"
        },
        {
            "id": "https://phpmemo.com/lesser-known-design-patterns.html",
            "url": "https://phpmemo.com/lesser-known-design-patterns.html",
            "title": "Lesser Known Design Patterns",
            "summary": "There are numerous lesser-known patterns that can significantly enhance your system design. This blog post will delve into some of them. The Laravel Pipeline pattern&hellip;",
            "content_html": "<p>There are numerous lesser-known patterns that can significantly enhance your system design. This blog post will delve into some of them.</p>\n<h2>Pipeline Pattern</h2>\n<p>The Laravel Pipeline pattern allows for a sequence of tasks or processes to be passed through a series of filters or pipes, each with a single responsibility, enhancing flexibility, testability, and extensibility.</p>\n<pre class=\"language-php\"><code>interface PipeInterface\n{\n\tpublic function handle($passable, Closure $next);\n}\n\nclass VerifyUserAge implements PipeInterface\n{\n\tpublic function handle($user, Closure $next)\n\t{\n\t\t// Skip this pipe if user is admin\n\t\tif ($user-&gt;isAdmin()) {\n\t\t\treturn $next($user);\n\t\t}\n\n\t\tif ($user-&gt;age &lt; 18) {\n\t\t\tthrow new \\Exception(\"User is not old enough\");\n\t\t}\n\t\treturn $next($user);\n\t}\n}\n\nclass ValidateUserEmail implements PipeInterface\n{\n\tpublic function handle($user, Closure $next)\n\t{\n\t\tif (!filter_var($user-&gt;email, FILTER_VALIDATE_EMAIL)) {\n\t\t\tthrow new \\Exception(\"Invalid email format\");\n\t\t}\n\t\treturn $next($user);\n\t}\n}\n\nclass NormalizeUserName implements PipeInterface\n{\n\tpublic function handle($user, Closure $next)\n\t{\n\t\t$user-&gt;name = trim(ucwords(strtolower($user-&gt;name)));\n\t\treturn $next($user);\n\t}\n}\n\nclass ProcessByType implements PipeInterface\n{\n\tpublic function __construct(private string $type) {}\n\n\tpublic function handle($data, Closure $next)\n\t{\n\t\tmatch ($this-&gt;type) {\n\t\t\t'premium' =&gt; $this-&gt;processPremiumUser($data),\n\t\t\t'standard' =&gt; $this-&gt;processStandardUser($data),\n\t\t\tdefault =&gt; null\n\t\t};\n\n\t\treturn $next($data);\n\t}\n}\n\n// User registration pipeline\nclass UserRegistrationPipeline\n{\n\tpublic function process($user)\n\t{\n\t\t$pipes = [\n\t\t\tVerifyUserAge::class,\n\t\t\tValidateUserEmail::class,\n\t\t\tNormalizeUserName::class,\n\t\t\tnew ProcessByType('premium'),\n\t\t];\n\n\t\treturn app(\\Illuminate\\Pipeline\\Pipeline::class)\n\t\t\t-&gt;send($user)\n\t\t\t-&gt;through($pipes)\n\t\t\t-&gt;thenReturn();\n\t}\n}\n\n// Usage example\nclass UserController\n{\n\tprotected $pipeline;\n\n\tpublic function __construct(UserRegistrationPipeline $pipeline)\n\t{\n\t\t$this-&gt;pipeline = $pipeline;\n\t}\n\n\tpublic function register(Request $request)\n\t{\n\t\ttry {\n\t\t\t$user = $this-&gt;pipeline-&gt;process(new User($request-&gt;all()));\n\t\t\t// Save user if all pipes pass\n\t\t\t$user-&gt;save();\n\t\t\treturn response()-&gt;json(['message' =&gt; 'User registered successfully']);\n\t\t} catch (\\Exception $e) {\n\t\t\treturn response()-&gt;json(['error' =&gt; $e-&gt;getMessage()], 400);\n\t\t}\n\t}\n}</code></pre>\n<h2>Tap pattern</h2>\n<p>The <code>tap</code> function takes two arguments: the first is the value to be passed, and the second is a closure. This closure receives the value, performs some operations on it, and then returns it.</p>\n<pre class=\"language-php\"><code>// instead of doing this\n$article = Article::findOrFail($id);\n$article-&gt;incrementViews();\n$article-&gt;doSomething();\n\nreturn $article;\n\n\n// we can keep related functionality to one block of code\nreturn tap(Article::findOrFail($id), function (Article $article) {\n\t$article-&gt;incrementViews();\n\t$article-&gt;doSomething();\n});</code></pre>\n<p>The <code>update</code> method typically returns a boolean value. However, by using the <code>tap</code> function, the <code>update</code> method instead returns the User model that was tapped. This functionality of <code>tap</code> makes it simple to ensure any method on an object returns the object itself.</p>\n<pre class=\"language-php\"><code>return tap($user)-&gt;update(['email' =&gt; $email]);</code></pre>\n<p><a href=\"https://medium.com/@tanmaymishu/the-anatomy-of-laravels-tap-function-ea239c9846ab\" target=\"_blank\" rel=\"noopener noreferrer\">The anatomy of Laravel’s tap() function</a></p>\n<h2><span style=\"color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit;\">Cache Refresh Ahead Pattern</span></h2>\n<p>This pattern ensures that the cache is updated before it expires, guaranteeing that users receive fresh data at all times. If the data is frequently accessed, it will always be cached.</p>\n<pre class=\"language-php\"><code>function cacheWithRefreshAhead(string $key, int $ttl, float $refreshAheadTime, \\Closure $callback): mixed\n{\n\t$cachedData = Cache::get($key);\n\n\tif ($cachedData) {\n\t\t$expiresAt = Cache::get(\"$key:expires_at\");\n\n\t\tif ($expiresAt &amp;&amp; Carbon::now()-&gt;diffInMinutes($expiresAt) &lt;= $ttl * $refreshAheadTime) {\n\t\t\t// dispatch a Job to update cache:\n\t\t\tCache::put($key, $callback(), $ttl);\n\t\t\tCache::put(\"$key:expires_at\", Carbon::now()-&gt;addMinutes($ttl), $ttl);\n\t\t}\n\n\t\treturn $cachedData;\n\t}\n\n\t// Cache miss, so cache it\n\t$data = $callback();\n\t// dispatch a Job to update cache:\n\tCache::put($key, $data, $ttl);\n\tCache::put(\"$key:expires_at\", Carbon::now()-&gt;addMinutes($ttl), $ttl);\n\n\treturn $data;\n}\n\n// Usage example \n$data = cacheWithRefreshAhead('some-key', 30, 0.7, function () {\n\t// Retrieve fresh data\n\treturn ['data' =&gt; 123];\n});</code></pre>",
            "author": {
                "name": "Enxas"
            },
            "tags": [
                   "PHP",
                   "Laravel",
                   "Design Patterns"
            ],
            "date_published": "2024-12-07T17:59:40+02:00",
            "date_modified": "2024-12-10T18:47:42+02:00"
        },
        {
            "id": "https://phpmemo.com/troubleshooting-php-jit-a-definitive-guide-to-enabling-performance-boost-when-configuration-fails.html",
            "url": "https://phpmemo.com/troubleshooting-php-jit-a-definitive-guide-to-enabling-performance-boost-when-configuration-fails.html",
            "title": "Troubleshooting PHP JIT: A Definitive Guide to Enabling Performance Boost When Configuration Fails",
            "summary": "Many posts online suggest that enabling PHP JIT is as simple as adding some values to the php.ini file, but that's not exactly the case.",
            "content_html": "<p>Many posts online suggest that enabling PHP JIT is as simple as adding some values to the <strong>php.ini</strong> file, but that's not exactly the case. Sometimes adding these configuration values doesn't seem to do anything. In this post, I'll show how to enable PHP JIT when nothing seems to work. I'll use a default Laravel Sail Docker container, but the idea is the same for any server running PHP.</p>\n<p>1. Check if a PHP extension is blocking JIT from loading. Type this command in the terminal to see JIT status:</p>\n<pre class=\"language-bash\"><code>./vendor/bin/sail php -r \"print_r(opcache_get_status(false)['jit']);\"</code></pre>\n<p class=\"whitespace-pre-wrap break-words\">If you see this warning, then a PHP extension is blocking JIT:</p>\n<blockquote>\n<p>PHP Warning: JIT is incompatible with third-party extensions that override zend_execute_ex(). JIT disabled. in Unknown on line 0.</p>\n</blockquote>\n<p>2. Disable problematic extensions. Laravel Sail Docker file installs many extensions, so we need to identify which ones are not compatible with PHP JIT. After disabling extensions one by one, I found that <strong>php8.3-pcov</strong> and <strong>php8.3-xdebug</strong> are problematic.</p>\n<p class=\"whitespace-pre-wrap break-words\">To disable these extensions:</p>\n<ul class=\"-mt-1 [li&gt;&amp;]:mt-2 list-disc space-y-2 pl-8\">\n<li class=\"whitespace-normal break-words\">Ensure your .env file doesn't have <strong>SAIL_XDEBUG_MODE</strong> or any other environmental values that enable xDebug</li>\n<li class=\"whitespace-normal break-words\">Add these values to your php.ini:</li>\n</ul>\n<pre class=\"language-bash\"><code>pcov.enabled=0\nxdebug.mode=off</code></pre>\n<p>Also, add these values to enable JIT:</p>\n<pre class=\"language-bash\"><code>[opcache]\nzend_extension=opcache.so\nopcache.enable=1\nopcache.enable_cli=1\nopcache.memory_consumption=128M\nopcache.interned_strings_buffer=8\nopcache.max_accelerated_files=4000\nopcache.revalidate_freq=60\nopcache.fast_shutdown=1\nopcache.jit_buffer_size=100M\nopcache.jit=tracing</code></pre>\n<p>3. <span style=\"color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);\">Restart If you're using Laravel Sail, rebuild your image with:</span></p>\n<ul class=\"-mt-1 [li&gt;&amp;]:mt-2 list-disc space-y-2 pl-8\">\n<li class=\"whitespace-normal break-words\"><code class=\"bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.3rem] px-1 py-px text-[0.9rem]\">sail down</code></li>\n<li class=\"whitespace-normal break-words\"><code class=\"bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.3rem] px-1 py-px text-[0.9rem]\">sail build</code></li>\n<li class=\"whitespace-normal break-words\"><code class=\"bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.3rem] px-1 py-px text-[0.9rem]\">sail up -d</code></li>\n</ul>\n<p class=\"whitespace-pre-wrap break-words\">Execute the command again to verify if JIT is properly enabled:</p>\n<pre class=\"language-bash\"><code>./vendor/bin/sail php -r \"print_r(opcache_get_status(false)['jit']);\"</code></pre>\n<p>And that's it. Hopefully, your PHP JIT is now enabled and working.</p>",
            "author": {
                "name": "Enxas"
            },
            "tags": [
                   "PHP",
                   "Laravel",
                   "JIT",
                   "Docker"
            ],
            "date_published": "2024-11-30T18:18:37+02:00",
            "date_modified": "2024-11-30T18:20:21+02:00"
        },
        {
            "id": "https://phpmemo.com/setting-up-laravel-dusk-for-laravel-sail-project-with-decoupled-vue-frontend-on-windows-2.html",
            "url": "https://phpmemo.com/setting-up-laravel-dusk-for-laravel-sail-project-with-decoupled-vue-frontend-on-windows-2.html",
            "title": "Setting up Laravel Dusk for Laravel Sail Project with Decoupled Vue Frontend on Windows",
            "summary": "Requirements Laravel Sail project Vue project with Vite WSL Installation Steps 1. In your docker-compose.yml file, add these ports to the \"selenium\" section: ports: -&hellip;",
            "content_html": "<div>\n<h2 class=\"font-600 text-xl font-bold\">Requirements</h2>\n<ul class=\"-mt-1 [li&gt;&amp;]:mt-2 list-disc space-y-2 pl-8\">\n<li class=\"whitespace-normal break-words\">Laravel Sail project</li>\n<li class=\"whitespace-normal break-words\">Vue project with Vite</li>\n<li class=\"whitespace-normal break-words\">WSL</li>\n</ul>\n</div>\n<div>\n<h2 class=\"font-600 text-xl font-bold\">Installation Steps<br><br></h2>\n1. In your <code class=\"bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.3rem] px-1 py-px text-[0.9rem]\">docker-compose.yml</code> file, add these ports to the \"selenium\" section:</div>\n<div>\n<pre class=\"language-yaml\"><code>ports:\n    - '${FORWARD_SELENIUM_PORT:-4444}:4444'\n    - '${FORWARD_SELENIUM_HEADFUL_PORT:-7900}:7900'</code></pre>\n</div>\n<div>2. Install Dusk:</div>\n<div>\n<pre class=\"language-bash\"><code>sail composer require --dev laravel/dusk</code></pre>\n<p>3. Create Dusk test and update configuration:</p>\n<pre class=\"language-bash\"><code>sail artisan dusk:install</code></pre>\n<p> 4. Create a test:</p>\n<pre class=\"language-bash\"><code>sail artisan dusk:make LoginTest</code></pre>\n<p> 5. Add this test method to verify functionality:</p>\n<pre class=\"language-php\"><code>public function testLogin(): void\n{\n    $this-&gt;browse(function (Browser $browser) {\n        $browser-&gt;visit('/')\n            -&gt;type('name', 'Josh')\n            -&gt;type('email', 'josh@example.com')\n            -&gt;type('password', 'hunter2')\n            -&gt;press('Login')\n            -&gt;waitForText('Logged In');\n    });\n}</code></pre>\n<h2 class=\"font-600 text-xl font-bold\">Configuration<br><br></h2>\n<p>Before running tests, ensure your Vue application running on Windows is accessible from within the Laravel Sail Docker container.<br><br></p>\n</div>\n<div>1. Host your Vue application with:\n<pre class=\"language-bash\"><code>npm run dev -- --host</code></pre>\n<p> 2. Create <code class=\"bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.3rem] px-1 py-px text-[0.9rem]\">.env.dusk</code> file in your Laravel application root with these values:</p>\n<pre class=\"language-bash\"><code>APP_URL=http://192.168.0.100:5174/\nDB_DATABASE=test_db\nLARAVEL_SAIL=1</code></pre>\n<p> (Replace IP address with your hosted Vue application IP address).</p>\n</div>\n<div>\n<h2 class=\"font-600 text-xl font-bold\">Running Tests<br><br></h2>\n<p class=\"whitespace-pre-wrap break-words\">Basic test execution:</p>\n</div>\n<div>\n<pre class=\"language-bash\"><code>sail dusk --env=.env.dusk</code></pre>\n</div>\n<div>\n<p>To view tests running visually:<br><br></p>\n1. Add to <code class=\"bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.3rem] px-1 py-px text-[0.9rem]\">.env.dusk</code>:</div>\n<div>\n<pre class=\"language-bash\"><code>DUSK_HEADLESS_DISABLED=1</code></pre>\n</div>\n<div>2. Visit <code class=\"bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.3rem] px-1 py-px text-[0.9rem]\">http://localhost:7900</code> (default password: 'secret')<br>\n<p class=\"whitespace-pre-wrap break-words\">Optionally, you can provide a custom PHPUnit configuration:</p>\n</div>\n<div>\n<pre class=\"language-bash\"><code>sail dusk --configuration phpunit.dusk.xml</code></pre>\n</div>\n<div>\n<div class=\"relative flex flex-col rounded-lg\">\n<div class=\"pointer-events-none sticky my-0.5 ml-0.5 flex items-center justify-end px-1.5 py-1 mix-blend-luminosity top-0\">\n<div class=\"from-bg-300/90 to-bg-300/70 pointer-events-auto rounded-md bg-gradient-to-b p-0.5 backdrop-blur-md\"> </div>\n</div>\n</div>\n</div>",
            "author": {
                "name": "Enxas"
            },
            "tags": [
                   "WSL",
                   "Vue",
                   "Testing",
                   "Laravel",
                   "Dusk",
                   "Docker"
            ],
            "date_published": "2024-11-17T14:06:12+02:00",
            "date_modified": "2024-11-17T21:32:57+02:00"
        }
    ]
}
