<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
    <title>PHPMemo</title>
    <link href="https://phpmemo.com/feed.xml" rel="self" />
    <link href="https://phpmemo.com" />
    <updated>2025-03-24T11:30:13+02:00</updated>
    <author>
        <name>Enxas</name>
    </author>
    <id>https://phpmemo.com</id>

    <entry>
        <title>Using PHP as a (Terrible) Video Player</title>
        <author>
            <name>Enxas</name>
        </author>
        <link href="https://phpmemo.com/using-php-as-a-terrible-video-player.html"/>
        <id>https://phpmemo.com/using-php-as-a-terrible-video-player.html</id>
            <category term="PHP"/>

        <updated>2025-03-22T14:57:27+02:00</updated>
            <summary>
                <![CDATA[
                    While browsing a forum, I noticed an ASCII art image, which made me wonder how such images are created. It turns out that the process&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>While browsing a forum, I noticed an ASCII art image, which made me wonder how such images are created. It turns out that the process is quite simple. All that is required is to iterate through an image’s pixels and replace them with ASCII characters. Darker pixels are replaced with characters that appear larger, while lighter pixels are replaced with smaller characters, such as a dot.</p>
<p>That led me to another thought: since a video is just a sequence of frames (images), could I encode every frame of a video into ASCII characters, effectively turning the video into an ASCII animation? And how difficult would that be to accomplish?</p>
<h3>Extracting Frames from a Video</h3>
<p>The first step is figuring out how to read a video frame by frame. I know PHP has built-in methods to read pixel data from an image, but how can I decode frames from a video? Apparently, PHP does not have libraries for video decoding by default, so I decided to use a popular encoding/decoding tool named <strong><a href="https://www.ffmpeg.org/" target="_blank" rel="noopener noreferrer">FFmpeg</a></strong>.</p>
<p>The idea is to use FFmpeg to decode the video frame by frame, then pass those frames to a PHP application. The application will iterate over each pixel of a frame and replace it with an ASCII character. The resulting ASCII frames can then be displayed in the terminal or saved to a file for later viewing.</p>
<h3>Using FFmpeg to Retrieve Frames</h3>
<p>Let’s start by constructing an FFmpeg command with arguments to extract frames one by one. The most important flags include:</p>
<ul>
<li><strong>Hardware acceleration</strong> (depending on the operating system)</li>
<li><strong>Grayscale conversion</strong>, since we are not displaying colors in the terminal, which simplifies choosing the appropriate ASCII characters</li>
<li><strong>Frame encoding as PNG images</strong>, since PNG is lossless and maintains the necessary details</li>
</ul>
<p>FFmpeg uses <strong>stdout</strong> to return frame data and <strong>stderr</strong> to print encoding status. The <code>-loglevel error</code> flag ensures that only errors are printed to the error stream, as the status messages are not needed.</p>
<pre class="language-php"><code>$hwaccel = match (true) {
	stristr(PHP_OS, 'linux') =&gt; " -hwaccel vaapi -vaapi_device /dev/dri/renderD128 ",
	stristr(PHP_OS, 'darwin') =&gt; " -hwaccel videotoolbox ",
	stristr(PHP_OS, 'win') =&gt; " -hwaccel dxva2 ",
	default =&gt; "",
};

$cmd = "\"$this-&gt;ffmpegPath\" $hwaccel -i " . escapeshellarg($videoPath) .
	" -vf \"fps={$settings['framerate']},scale={$settings['resolution']},format=gray\" " .
	" -fflags nobuffer -loglevel error -flush_packets 1 -update 1 " .
	" -f image2pipe -pix_fmt gray -vcodec png -";</code></pre>
<h3>Processing Frames in PHP</h3>
<p>Now, let’s start the FFmpeg process with the built command and open pipes to receive frame data from the FFmpeg process.</p>
<pre class="language-php"><code>$process = proc_open($cmd, [
	0 =&gt; ["pipe", "r"],
	1 =&gt; ["pipe", "w"],
	2 =&gt; ["pipe", "w"]
], $pipes);</code></pre>
<p>Next, we read from <code>$pipes[1]</code>, which corresponds to <strong>STDOUT</strong>. This is where the PNG-encoded frame data is received from the FFmpeg process. Since we might receive only a portion of a frame at a time, we accumulate chunks of data into a buffer. Once the buffer contains a complete PNG image, it is passed for further processing.</p>
<pre class="language-php"><code>$buffer = '';

// Process each frame
while (true) {
	$status = proc_get_status($process);
	if (!$status['running'] &amp;&amp; feof($pipes[1])) {
		break;
	}

	// Read data from FFmpeg output
	if (($chunk = fread($pipes[1], 4096)) !== false &amp;&amp; $chunk !== '') {
		$buffer .= $chunk;
	}

	// Process complete PNG images in the buffer
	$buffer = $this-&gt;processFrames($buffer, $frameCallback);
}</code></pre>
<h3>Converting Frames to ASCII</h3>
<p>This is the heart of the application. The accumulated PNG buffer is turned into a <strong>GdImage</strong> object, which PHP can use to access pixel data. Instead of iterating over every single pixel, we divide the image into horizontal and vertical blocks. Each block’s brightness is determined by sampling the pixel at its center. Since ASCII characters are larger than pixels, this approach provides a reasonable approximation of the image.</p>
<p>We then map the brightness value to a corresponding character from a predefined <strong>grayscale ASCII character set</strong>. The process continues line by line until the entire frame is converted into ASCII characters.</p>
<pre class="language-php"><code>$grayCharacters = "$@B%8&amp;WM#*+=-:. "; // ASCII gradient from dark to light
$image = @imagecreatefromstring($frameData);

$asciiFrame = [];

for ($y = 0; $y &lt; $newHeight; $y++) {
	$row = '';
	$baseY = $y * $this-&gt;widthSubsample;

	for ($x = 0; $x &lt; $newWidth; $x++) {
		$baseX = $x * $this-&gt;heightSubsample;

		// Sample center pixel for each block
		$sampleX = min($baseX + intdiv($this-&gt;heightSubsample, 2), $width - 1);
		$sampleY = min($baseY + intdiv($this-&gt;widthSubsample, 2), $height - 1);

		$grayValue = imagecolorat($image, $sampleX, $sampleY);
		// Map color value to ASCII character
		$index = (int) ceil((strlen($grayCharacters) - 1) * $grayValue / 255);
		$row .= $grayCharacters[$index];
	}

	$asciiFrame[] = $row;
}</code></pre>
<h3>Storing and Displaying ASCII Frames</h3>
<p>Once an ASCII frame is generated, it can be displayed in the terminal or saved to a file. To make the ASCII video file smaller, I used PHP’s <code>gzcompress</code> function to compress frame data.</p>
<pre class="language-php"><code>$compressed = gzcompress($asciiFrame);
fwrite($file, base64_encode($compressed) . "\n");</code></pre>
<h3>Results and Conclusion</h3>
<figure class="post__image post__image--center"><img loading="lazy"  src="https://phpmemo.com/media/posts/10/WindowsTerminal_Hi7kO7jpGA-2.gif" alt="ASCII Movie Example" width="1920" height="1042"></figure>
<p>To test compression and playback, I used the open-source animated movie <strong><a href="https://peach.blender.org/download/" target="_blank" rel="noopener noreferrer">Big Buck Bunny</a></strong>. The original <strong>691 MB</strong> video file was compressed into a <strong>52 MB</strong> ASCII movie file. Playback worked without any issues — I only needed to reduce the terminal font size using <code>Ctrl</code> + <code>-</code> to fit more details on the screen.</p>
<p>During this project, I also developed a PHP library named <strong>Scoria</strong> for ASCII video encoding, decoding, and playback. You can find the code on <strong><a href="https://github.com/enxas/scoria" target="_blank" rel="noopener noreferrer">GitHub</a></strong>.</p>
<p>While I can’t imagine watching ASCII movies regularly, this was a fun and unusual project to experiment with!</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Building My Own Async PHP</title>
        <author>
            <name>Enxas</name>
        </author>
        <link href="https://phpmemo.com/making-my-own-async-php.html"/>
        <id>https://phpmemo.com/making-my-own-async-php.html</id>
            <category term="PHP"/>

        <updated>2025-03-07T16:54:27+02:00</updated>
            <summary>
                <![CDATA[
                    A lot of what I do involves data processing. I retrieve resources like database records or files, then iterate through each one to process it.
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>A lot of what I do involves data processing. I retrieve resources like database records or files, then iterate through each one to process it. The biggest problem I run into is performance due to the sheer amount of data that needs processing. Since PHP runs on a single thread, if I need to process a million records, PHP has to go through each one sequentially. However, modern computers are capable of executing multiple tasks simultaneously, so can PHP leverage that hardware to process data in parallel?</p>
<h2>Existing Solutions</h2>
<p>There are many libraries and frameworks that help achieve asynchronous PHP, such as Swoole, ReactPHP, and Amp, as well as extensions like PThreads and Parallel. However, my goal was to use native PHP features without additional dependencies while still being able to receive data after it has been processed. This left me with the following options:</p>
<ul>
<li><strong>pcntl_fork</strong> - Requires the Process Control extension and does not work on non-Unix systems.</li>
<li><strong>stream_socket_server</strong> - Requires creating a server, which seems excessive.</li>
<li><strong>shell_exec() or exec()</strong> - Cannot capture real-time output.</li>
<li><strong>proc_open()</strong> - Does not require extensions, can capture output in real-time, and is lightweight.</li>
</ul>
<p>I decided to go with <code>proc_open()</code>. In a serious application, you would likely use existing solutions, but this was an experiment to see how close I could get to async PHP using built-in features.</p>
<h2>Building Blocks</h2>
<p>These are the key functions that enable us to implement something resembling async PHP:</p>
<ul>
<li><strong>proc_open</strong> - Starts an external process and allows interaction via pipes (stdin, stdout, stderr).</li>
<li><strong>stream_set_blocking</strong> - Sets a stream to blocking or non-blocking mode, allowing us to avoid execution being halted while waiting for input.</li>
<li><strong>stream_select</strong> - Monitors multiple streams for readability, writability, or errors, making it useful for handling multiple socket connections or non-blocking I/O.</li>
<li><strong>stream_get_contents</strong> - Reads the full content from a stream, useful for reading from pipes, sockets, or remote connections.</li>
</ul>
<h2>The Plan</h2>
<p>The library should be able to take in tasks (callables) and process each one in a separate process so they do not block each other. If I have 1000 tasks, I should not have all 1000 running simultaneously, as too much time would be spent on context switching. Instead, the number of active tasks should be limited — ideally, to match the available CPU threads. Data from each process should be retrieved as soon as it becomes available, and when a process ends, another should take its place to ensure that the maximum number of allowed processes is always working on tasks.</p>
<h2>Execution</h2>
<p>I liked the API of the Spatie Async library, so I decided to mimic it. In the example below, 15 tasks are created and executed in parallel, with their results summed up:</p>
<pre class="language-php"><code>use Enxas\Pumice;

$pumice = Pumice::create();
$total = 0;

for ($i = 0; $i &lt; 15; $i++) {
	$pumice
		-&gt;add([new StuffCalculator, 'calculate'])
		-&gt;then(function (mixed $output) use (&amp;$total) {
			$total += $output;
		})-&gt;catch(function (Throwable $exception) {
			echo "Error: {$exception-&gt;getMessage()}\n";
		});
}

$pumice-&gt;wait();

echo $total;</code></pre>
<p>If no maximum number of concurrent processes is provided, then the available thread count is used:</p>
<pre class="language-php"><code>private function getProcessorCores(): int
{
	return (int) match (PHP_OS_FAMILY) {
		'Windows' =&gt; shell_exec('echo %NUMBER_OF_PROCESSORS%'),
		'Linux' =&gt; shell_exec('nproc'),
		'Darwin' =&gt; shell_exec('sysctl -n hw.ncpu'), // MacOS
		default =&gt; 8,
	};
}</code></pre>
<p>Since tasks are objects and PHP does not allow passing objects as command-line arguments, I serialize and base64 encode the object before passing it to a separate worker process. Once the process is created, I interact with it through stdin, stdout, and stderr pipes, setting those pipes to non-blocking mode to prevent blocking other processes.</p>
<pre class="language-php"><code>$serializedTask = base64_encode(serialize($task));
$cmd = ["php", "-f", __DIR__ . "/worker.php", $serializedTask];

$process = proc_open($cmd, $this-&gt;descriptorSpec, $this-&gt;pipes[$index]);

if (is_resource($process)) {
	stream_set_blocking($this-&gt;pipes[$index][self::STDOUT], false);
	stream_set_blocking($this-&gt;pipes[$index][self::STDERR], false);

	$this-&gt;processes[$index] = $process;
}</code></pre>
<p>The <code>worker.php</code> script is straightforward. It decodes and unserializes the received command-line argument (the task object), executes the callable, and then returns the serialized and encoded response back to the main process.</p>
<pre class="language-php"><code>if ($argc &gt;= 2) {
	try {
		$task = unserialize(base64_decode($argv[1]));

		if (!is_callable($task)) {
			throw new Exception("Task is not callable.");
		}

		// Execute task
		$output = $task();

		// Wrap successful output
		$response = [
			'status' =&gt; 'success',
			'data'   =&gt; $output
		];
	} catch (Throwable $e) {
		// Wrap error output
		$response = [
			'status'  =&gt; 'error',
			'message' =&gt; $e-&gt;getMessage()
		];
	}

	// Always return a structured response
	echo base64_encode(serialize($response));

	flush();
}</code></pre>
<h2>The Main Logic</h2>
<p>The core logic happens in the <code>wait()</code> function. It starts an initial batch of tasks, ensuring that no more than the allowed number of tasks run at the same time. As each task completes, a new one starts to maintain the limit.</p>
<pre class="language-php"><code>// Start a batch of $maxConcurrent tasks
while (count($this-&gt;processes) &lt; $this-&gt;maxConcurrent &amp;&amp; $this-&gt;taskIndex &lt; count($this-&gt;tasks)) {
	$this-&gt;startNewTask();
}</code></pre>
<p>We monitor the output pipes of the running processes. <code>stream_select()</code> blocks execution until at least one process has data available:</p>
<pre class="language-php"><code>$readStreams = array_map(fn($pipes) =&gt; $pipes[self::STDOUT], $this-&gt;pipes);
$writeStreams = null;
$exceptStreams = null;

// Wait until one or more streams are ready to read
if (stream_select($readStreams, $writeStreams, $exceptStreams, null) &gt; 0) {</code></pre>
<p>When output is available, we retrieve, decode, and deserialize it:</p>
<pre class="language-php"><code>foreach ($this-&gt;processes as $i =&gt; $process) {
	if (in_array($this-&gt;pipes[$i][self::STDOUT], $readStreams, true)) {
		$encodedOutput = stream_get_contents($this-&gt;pipes[$i][self::STDOUT]);

		if ($encodedOutput !== false &amp;&amp; $encodedOutput !== '') {
			$output = unserialize(base64_decode($encodedOutput));</code></pre>
<p>Finally, we call the success or error callbacks with the resulting data:</p>
<pre class="language-php"><code>// Handle success/failure callbacks
if (isset($output['status']) &amp;&amp; $output['status'] === 'error') {
	if ($this-&gt;callbacks[$i]['catch']) {
		call_user_func($this-&gt;callbacks[$i]['catch'], new \Exception($output['message']));
	}
} elseif ($this-&gt;callbacks[$i]['then']) {
	call_user_func($this-&gt;callbacks[$i]['then'], $output['data']);
}</code></pre>
<h2>The Result</h2>
<p>Let's test the performance improvement by comparing async execution with synchronous execution. First lets create a worker class.</p>
<pre class="language-php"><code>&lt;?php

namespace App\Workers;

class StuffCalculator
{
	public function calculate(): float
    {
		$result = 0;

        for ($i = 0; $i &lt; 10_000_000; $i++) {
            $result += sqrt($i) * log($i + 1) * sin($i) * cos($i) * exp($i % 10);
        }

		return $result;
    }
}
</code></pre>
<p>Then measure time how long it takes to complete 15 tasks between sync and async versions.</p>
<pre class="language-php"><code>$startTime1 = microtime(true);

$pumice = Pumice::create();
$total1 = 0;

for ($i = 0; $i &lt; 15; $i++) {
	$pumice
		-&gt;add([new StuffCalculator, 'calculate'])
		-&gt;then(function (mixed $output) use (&amp;$total1) {
			$total1 += $output;
		})-&gt;catch(function (Throwable $exception) {
			echo "Error: {$exception-&gt;getMessage()}\n";
		});
}

$pumice-&gt;wait();

$elapsedTime1 = (microtime(true) - $startTime1) * 1000;

$startTime2 = microtime(true);

$total2 = 0;
for ($i = 0; $i &lt; 15; $i++) {
	$total2 += (new StuffCalculator)-&gt;calculate();
}

$elapsedTime2 = (microtime(true) - $startTime2) * 1000;


var_dump([$elapsedTime1, $elapsedTime2, $total1, $total2]);</code></pre>
<p>Results:</p>
<pre><code>array(4) {
  [0]=&gt; float(7125.4589557647705)
  [1]=&gt; float(32699.30911064148)
  [2]=&gt; float(2001088973.8368132)
  [3]=&gt; float(2001088973.8368132)
}
</code></pre>
<p>The async version took around <strong>7 seconds</strong>, while the synchronous version took <strong>32 seconds</strong>. The computed results are identical, showing a significant performance boost.</p>
<p>In the process, I created a small library named <strong>Pumice</strong>. The source code is available on <a href="https://github.com/enxas/pumice" target="_blank" rel="noopener noreferrer">GitHub</a>. This was a challenging but rewarding project, proving that PHP can achieve parallel processing with built-in features.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Demystifying Laravel&#x27;s Higher Order Messaging</title>
        <author>
            <name>Enxas</name>
        </author>
        <link href="https://phpmemo.com/higher-order-messages.html"/>
        <id>https://phpmemo.com/higher-order-messages.html</id>
            <category term="PHP"/>
            <category term="Laravel"/>
            <category term="Design Patterns"/>

        <updated>2025-02-02T15:20:45+02:00</updated>
            <summary>
                <![CDATA[
                    I was browsing some Laravel project codebases when I came across code that looked like this: $participants = collect([...]); $team2Participants = $participants-&gt;filter-&gt;belongsToTeam(2); $totalScore = $team2Participants-&gt;sum-&gt;score;&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>I was browsing some Laravel project codebases when I came across code that looked like this:</p>
<pre class="language-php"><code>$participants = collect([...]);
$team2Participants = $participants-&gt;filter-&gt;belongsToTeam(2);
$totalScore = $team2Participants-&gt;sum-&gt;score;</code></pre>
<p>I had a good idea of what this code does, but I had never seen collection methods written like this before. When I call collection methods, I usually provide a callback, like this:</p>
<pre class="language-php"><code>$currentYearOrders = $participants-&gt;filter(function ($participant) {
    return $participant-&gt;belongsToTeam(2);
});

$currentYearAmount = $currentYearOrders-&gt;sum(function ($order) {
    return $order-&gt;score;
});</code></pre>
<p>This made me wonder: what is this syntax, and how does it work? Spoiler alert: it involves some magic!</p>
<p>After some research, I learned that Laravel calls this pattern <strong><a href="https://laravel.com/docs/11.x/collections#higher-order-messages" target="_blank" rel="noopener noreferrer">Higher Order Messaging</a></strong>. To better understand how it works, I decided to reimplement it in vanilla PHP.</p>
<h3>Creating a Basic Collection Class</h3>
<p>First, I needed a collection class, so I created one with <code>filter()</code> and <code>sum()</code> methods:</p>
<pre class="language-php"><code>class MyCollection
{
    public function __construct(private array $items = []) {}

    public function filter(callable $callback): static
    {
        return new static(array_filter($this-&gt;items, $callback));
    }

    public function sum(callable $callback): int|float
    {
        return array_reduce($this-&gt;items, fn($result, $item) =&gt; $result + $callback($item), 0);
    }
}</code></pre>
<p>This is a simple wrapper class. The <code>filter()</code> method calls PHP’s <code>array_filter()</code> and returns a new instance of <code>MyCollection</code> with items filtered using the provided callback. The <code>sum()</code> method iterates over array items and adds them up.</p>
<h3>Creating a Basic Participant Class</h3>
<p>Next, I created a basic <code>Participant</code> data class. It holds the team number a participant belongs to and their score. It also has a method to check if a participant belongs to a specific team:</p>
<pre class="language-php"><code>class Participant
{
    public function __construct(private int $teamNumber, public int $score = 0) {}

    public function belongsToTeam(int $teamNumber): bool
    {
        return $this-&gt;teamNumber === $teamNumber;
    }
}</code></pre>
<h3>Testing the Functionality</h3>
<p>Now, let’s check if our implementation works as expected:</p>
<pre class="language-php"><code>$participants = new MyCollection([
    new Participant(teamNumber: 1, score: 11),
    new Participant(teamNumber: 1, score: 6),
    new Participant(teamNumber: 2, score: 5),
    new Participant(teamNumber: 2, score: 8),
    new Participant(teamNumber: 2, score: 7),
    new Participant(teamNumber: 3, score: 20),
]);

// Result: 3 items
$team2Participants = $participants-&gt;filter(fn($participant) =&gt; $participant-&gt;belongsToTeam(2));
// Result: 20
$totalScore = $team2Participants-&gt;sum(fn($participant) =&gt; $participant-&gt;score);

// Chaining the methods
$totalScore = $participants
    -&gt;filter(fn($participant) =&gt; $participant-&gt;belongsToTeam(2))
    -&gt;sum(fn($participant) =&gt; $participant-&gt;score);</code></pre>
<p>Everything works as expected. We create six participants and filter out everyone except those from team 2. We are left with three participants. When we sum their scores, the result is 20. We can even chain <code>sum()</code> after <code>filter()</code> because <code>filter()</code> returns a new instance of <code>MyCollection</code>. With our basic collection functionality in place, it’s time for the fun part—replicating Laravel’s Higher Order Messaging.</p>
<h3>Implementing Higher Order Messaging</h3>
<p>When we call a property on Laravel’s collection that doesn’t exist, such as:</p>
<pre class="language-php"><code>$collection-&gt;food;</code></pre>
<p>Laravel triggers the magic <code>__get()</code> method on the collection, which instantiates a class named <a href="https://github.com/laravel/framework/blob/11.x/src/Illuminate/Collections/HigherOrderCollectionProxy.php" target="_blank" rel="noopener noreferrer">HigherOrderCollectionProxy</a> and passes <code>$collection</code> and <code>food</code> as parameters (<code>HigherOrderCollectionProxy($collection, 'food')</code>). When we call a method or try to get a property on the <code>HigherOrderCollectionProxy</code> class, it uses <code>__get()</code> and <code>__call()</code> magic methods to proxy that method or property call back to <code>$collection</code>.</p>
<p>Let’s modify our <code>MyCollection</code> class to add the <code>__get()</code> method:</p>
<pre class="language-php"><code>class MyCollection
{
    // ...

    public function __get(string $key)
    {
        return new HigherOrderCollectionProxy($this, $key);
    }

    // ...
}</code></pre>
<p>Now, when <code>$participants-&gt;filter</code> is called, it creates an instance of <code>HigherOrderCollectionProxy</code>, passing the collection and method name (<code>filter</code>) to that instance.</p>
<h3>Creating the HigherOrderCollectionProxy Class</h3>
<pre class="language-php"><code>class HigherOrderCollectionProxy
{
    public function __construct(private $collection, private string $collMethod) {}

    public function __call(string $method, array $parameters)
    {
        return $this-&gt;collection-&gt;{$this-&gt;collMethod}(fn($value) =&gt; $value-&gt;{$method}(...$parameters));
    }

    public function __get(string $key)
    {
        return $this-&gt;collection-&gt;{$this-&gt;collMethod}(fn($value) =&gt; $value-&gt;{$key});
    }
}</code></pre>
<p>This is a simplified reimplementation of Laravel’s actual <code>HigherOrderCollectionProxy</code> to demonstrate the concept. The key idea is:</p>
<ul>
<li>When calling <code>$participants-&gt;filter-&gt;belongsToTeam(2)</code>, the proxy class's <code>__call()</code> magic method is triggered. This method then invokes the <code>filter</code> method on the collection, passing a callback that calls <code>belongsToTeam(2)</code> on each item in the collection.</li>
<li>Similarly, when calling <code>$team2Participants-&gt;sum-&gt;score</code>, the proxy class's <code>__get()</code> magic method is triggered. This retrieves the <code>score</code> property from each item in the collection before summing the values.</li>
</ul>
<pre class="language-php"><code>// Higher Order Messages

$team2Participants = $participants-&gt;filter-&gt;belongsToTeam(2);

$totalScore = $team2Participants-&gt;sum-&gt;score;

// chaining
$currentYearAmount = $participants-&gt;filter-&gt;belongsToTeam(2)-&gt;sum-&gt;score;</code></pre>
<h3>Conclusion</h3>
<p>With this approach, we’ve successfully replicated Laravel’s Higher-Order Messaging in vanilla PHP. Surprisingly, it was easier than expected, proving that true ingenuity lies in simplicity.</p>
<p>You can find the complete code in this <a href="https://gist.github.com/enxas/d439384b8ce44a7cadc77313dd5af7dc" target="_blank" rel="noopener noreferrer">GitHub Gist</a>.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>How to Insert 1 Million Records Lightning-Fast</title>
        <author>
            <name>Enxas</name>
        </author>
        <link href="https://phpmemo.com/fastest-way-to-insert-one-million-records-to-mysql-database.html"/>
        <id>https://phpmemo.com/fastest-way-to-insert-one-million-records-to-mysql-database.html</id>
            <category term="PHP"/>
            <category term="MySQL"/>
            <category term="Laravel"/>

        <updated>2024-12-12T21:49:53+02:00</updated>
            <summary>
                <![CDATA[
                    When working with large datasets, inserting a massive number of records into a database can become painfully slow. Fortunately, MySQL provides an optimized solution: the&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>When working with large datasets, inserting a massive number of records into a database can become painfully slow. Fortunately, MySQL provides an optimized solution: the <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.3rem] px-1 py-px text-[0.9rem]">LOAD DATA</code> statement. This method is significantly faster than traditional insertion methods, making it ideal for bulk data imports.</p>
<p>In this tutorial, I'll demonstrate how to generate, export, and import one million records into a MySQL database using Laravel. The principles discussed can be applied to various PHP applications.</p>
<h2 class="font-600 text-xl font-bold">Creating the Database Schema</h2>
<p class="whitespace-pre-wrap break-words">Let's start by defining a schema for a <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.3rem] px-1 py-px text-[0.9rem]">shops</code> table:</p>
<pre class="language-php"><code>Schema::create('shops', function (Blueprint $table) {
	$table-&gt;id();
	$table-&gt;string('name');
	$table-&gt;text('description');
	$table-&gt;string('email')-&gt;unique();
	$table-&gt;date('established_date');
	$table-&gt;time('opening_time'); 
	$table-&gt;decimal('rating', 3, 2);
	$table-&gt;boolean('is_open');
});</code></pre>
<h2 class="font-600 text-xl font-bold">Generating Test Data</h2>
<p class="whitespace-pre-wrap break-words">To populate our database, we'll use the Faker library to generate realistic sample data:</p>
<pre class="language-php"><code>$faker = \Faker\Factory::create();

$shops = [];

for ($i = 0; $i &lt; 1_000_000; $i++) {
	$shops[] = [
		'name' =&gt; $faker-&gt;company,
		'description' =&gt; $faker-&gt;paragraph,
		'email' =&gt; $faker-&gt;unique()-&gt;safeEmail,
		'established_date' =&gt; $faker-&gt;date,
		'opening_time' =&gt; $faker-&gt;time,
		'rating' =&gt; $faker-&gt;randomFloat(2, 0, 5),
		'is_open' =&gt; $faker-&gt;boolean,
	];

	// insert in batches to avoid memory issues
	if ($i % 1000 === 0) {
		DB::table('shops')-&gt;insert($shops);
		$shops = [];
	}
}

// insert any remaining records
if (!empty($shops)) {
	DB::table('shops')-&gt;insert($shops);
}</code></pre>
<h2 class="font-600 text-xl font-bold">Exporting Data to CSV</h2>
<p class="whitespace-pre-wrap break-words">Next, we'll export the records to a CSV file:</p>
<pre class="language-php"><code>$filePath = storage_path('app/shops.csv');
		
$file = fopen($filePath, 'w');

DB::table('shops')-&gt;chunkById(10_000, function ($shops) use ($file) {
	foreach ($shops as $shop) {
		$row = [
			$shop-&gt;id, 
			$shop-&gt;name, 
			$shop-&gt;description, 
			$shop-&gt;email, 
			$shop-&gt;established_date, 
			$shop-&gt;opening_time, 
			$shop-&gt;rating, 
			$shop-&gt;is_open,
		];

		fputcsv($file, $row, eol: "\n");
	}
});

fclose($file);</code></pre>
<p>Now that we have all of our data in a CSV file, we can clean the <code>shops</code> table:</p>
<pre class="language-sql"><code>TRUNCATE TABLE shops;</code></pre>
<h2>Importing data (slow)</h2>
<p>This is the standard approach for writing code to import data:</p>
<pre class="language-php"><code>DB::statement('ALTER TABLE shops DISABLE KEYS');

$handle = fopen(storage_path('app/shops.csv'), 'r');
$shops = [];

while (($data = fgetcsv($handle, 500, ',')) !== false) {
	$shops[] = [
		'id' =&gt; $data[0],
		'name' =&gt; $data[1],
		'description' =&gt; $data[2],
		'email' =&gt; $data[3],
		'established_date' =&gt; $data[4],
		'opening_time' =&gt; $data[5],
		'rating' =&gt; $data[6],
		'is_open' =&gt; $data[7],
	];

	// insert in batches to avoid memory issues
	if (count($shops) % 1000 === 0) {
		DB::table('shops')-&gt;insert($shops);
		$shops = [];
	}
}

// insert any remaining records
if (count($shops) &gt; 0) {
	DB::table('shops')-&gt;insert($shops);
}

fclose($handle);

DB::statement('ALTER TABLE shops ENABLE KEYS');</code></pre>
<p>The issue with this approach is that it’s slow. It took approximately 7 minutes and 40 seconds to import all the data.</p>
<h2 class="font-600 text-xl font-bold">Preparing for Import</h2>
<p class="whitespace-pre-wrap break-words">Before doing <code>LOAD DATA</code> import, we need to make a few configurations:</p>
<h3 class="font-600 text-lg font-bold">1. Check and Enable local_infile</h3>
<p class="whitespace-pre-wrap break-words">First, verify if the <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.3rem] px-1 py-px text-[0.9rem]">local_infile</code> feature is enabled in MySQL database:</p>
<pre class="language-sql"><code>SHOW GLOBAL VARIABLES LIKE 'local_infile';</code></pre>
<p>If it's OFF, enable it:</p>
<pre class="language-sql"><code>SET GLOBAL local_infile = TRUE;</code></pre>
<h3 class="font-600 text-lg font-bold">2. Configure Laravel Database Connection</h3>
<p class="whitespace-pre-wrap break-words">In <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.3rem] px-1 py-px text-[0.9rem]">config/database.php</code>, add the <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.3rem] px-1 py-px text-[0.9rem]">local_infile</code> option:</p>
<div>
<pre class="language-apacheconf"><code>'mysql' =&gt; [
    // ... other configurations
    'options' =&gt; extension_loaded('pdo_mysql') ? array_filter([
        PDO::MYSQL_ATTR_LOCAL_INFILE =&gt; true,
    ]) : [],
],</code></pre>
<h2 class="font-600 text-xl font-bold">Importing Data Using LOAD DATA (fast)</h2>
<p class="whitespace-pre-wrap break-words">Now we're ready to import the data efficiently:</p>
<pre class="language-php"><code>$filePath = storage_path('app/shops.csv');

DB::statement('ALTER TABLE shops DISABLE KEYS');

DB::unprepared("
    LOAD DATA LOCAL INFILE '$filePath' 
    INTO TABLE shops 
    FIELDS TERMINATED BY ',' 
    OPTIONALLY ENCLOSED BY '\"' 
    LINES TERMINATED BY '\\n' 
    IGNORE 0 ROWS 
    (id, name, description, email, established_date, opening_time, rating, is_open)
");

DB::statement('ALTER TABLE shops ENABLE KEYS');</code></pre>
<h2 class="font-600 text-xl font-bold">Performance Insights</h2>
<p class="whitespace-pre-wrap break-words">Wit this approach, importing a 233 MB CSV file with one million records took approximately 40 seconds—a remarkable improvement over traditional insertion methods.</p>
<h2>Some Considerations</h2>
<ul>
<li class="whitespace-normal break-words">Disable keys before bulk import and re-enable them after import.</li>
<li>For security reasons <code>local_infile</code> should be disabled when it's not in use.</li>
<li>Large CSV file imports slow down over time, so it's better to import two 100-million record files than one 200-million record file.</li>
</ul>
</div>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Identifying and Logging Duplicate Queries in Laravel Requests</title>
        <author>
            <name>Enxas</name>
        </author>
        <link href="https://phpmemo.com/identifying-and-logging-duplicate-queries-in-laravel-requests.html"/>
        <id>https://phpmemo.com/identifying-and-logging-duplicate-queries-in-laravel-requests.html</id>
            <category term="PHP"/>
            <category term="Laravel"/>
            <category term="Debug"/>

        <updated>2024-12-10T21:01:22+02:00</updated>
            <summary>
                <![CDATA[
                    When developing your Laravel application, you want to avoid unnecessarily making duplicate requests for performance reasons. However, it can be challenging to identify how many&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>When developing your Laravel application, you want to avoid unnecessarily making duplicate requests for performance reasons. However, it can be challenging to identify how many and which queries are duplicates. Here's a helper script that logs duplicate queries to the <code>laravel.log</code> file and records how many times they were executed.</p>
<p>Place this code in the <code>boot()</code> method of your <code>AppServiceProvider.php</code> file, then check your <code>laravel.log</code> file. This code uses Redis, but you can swap it to Cache.</p>
<pre class="language-php"><code>Redis::del('QueryStats');

Event::listen(QueryExecuted::class, function (QueryExecuted $event) {
	Redis::rpush('QueryStats', json_encode([
		'connection' =&gt; $event-&gt;connectionName,
		'query' =&gt; $event-&gt;sql,
		'bindings' =&gt; $event-&gt;bindings,
		'time' =&gt; $event-&gt;time,
		'trace' =&gt; collect(debug_backtrace())-&gt;map(function ($trace) {
			return Arr::only($trace, ['file', 'line', 'class', 'method']);
		})-&gt;toArray(),
	]));
});

$this-&gt;app-&gt;terminating(function () {
	$stats = Redis::lrange('QueryStats', 0, -1);

	$data = [
		'query_count' =&gt; 0,
	];

	foreach ($stats as $stat) {
		$queryStat = json_decode($stat);

		if (str_contains($queryStat-&gt;query, 'telescope_')) {
			continue;
		}

		if (!isset($data[$queryStat-&gt;query])) {
			$data[$queryStat-&gt;query] = 1;
		} else {
			$data[$queryStat-&gt;query] += 1;
		}

		$data['query_count'] += 1;

		arsort($data);
	}

	Log::info($data);
});</code></pre>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Most Popular Design Patterns</title>
        <author>
            <name>Enxas</name>
        </author>
        <link href="https://phpmemo.com/most-popular-design-patterns.html"/>
        <id>https://phpmemo.com/most-popular-design-patterns.html</id>
            <category term="PHP"/>
            <category term="Design Patterns"/>

        <updated>2024-12-08T16:42:42+02:00</updated>
            <summary>
                <![CDATA[
                    Throughout my experience, these design patterns have stood out to me. It's useful for creating loose coupling between components, and enabling a one-to-many dependency between&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <div>
<p>Throughout my experience, these design patterns have stood out to me.</p>
<h2>Observer Pattern</h2>
</div>
<p>It's useful for creating loose coupling between components, and enabling a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically without them needing to constantly poll for changes.</p>
<pre class="language-php"><code>enum ProductEvent
{
	case Available;
	case Discounted;
}

interface ProductObserver
{
	function notify(Product $product, ProductEvent $event): void;
}

class Product
{
	/**
	 * @var ProductObserver[]
	 */
	private $observers = [];


	function changeAvailability()
	{
		// change availability

		$this-&gt;notify(ProductEvent::Available);
	}

	function setDiscount()
	{
		// set discount

		$this-&gt;notify(ProductEvent::Discounted);
	}

	// ----------- event code -----------

	function attach(ProductObserver $observer)
	{
		$this-&gt;observers[spl_object_hash($observer)] = $observer;
	}

	function detach(ProductObserver $observer)
	{
		unset($this-&gt;observers[spl_object_hash($observer)]);
	}

	function notify(ProductEvent $event)
	{
		foreach ($this-&gt;observers as $observer) {
			$observer-&gt;notify($this, $event);
		}
	}
}

class Emailer implements ProductObserver
{
	function notify(Product $product, ProductEvent $event): void
	{
		match ($event) {
			ProductEvent::Available =&gt; $this-&gt;sendProductAvailableEmail(),
			ProductEvent::Discounted =&gt; $this-&gt;sendProductDiscountedEmail(),
		};
	}

	function sendProductAvailableEmail()
	{
		echo 'Sending product available email' . PHP_EOL;
	}

	function sendProductDiscountedEmail()
	{
		echo 'Sending product discounted email' . PHP_EOL;
	}
}

class Logger implements ProductObserver
{
	function notify(Product $product, ProductEvent $event): void
	{
		echo 'Product updated: ' . $event-&gt;name  . PHP_EOL;
	}
}

$product = new Product;
$logger = new Logger;
$emailer = new Emailer;

$product-&gt;attach($logger);
$product-&gt;attach($emailer);

$product-&gt;changeAvailability();
$product-&gt;setDiscount();

$product-&gt;detach($emailer);

$product-&gt;changeAvailability();
$product-&gt;setDiscount();</code></pre>
<div>
<h2>Facade Pattern</h2>
<p>The Facade design pattern provides a simplified, unified interface to a complex subsystem, hiding intricate interactions and making the system easier to use and modify. It reduces complexity by offering a clean, high-level entry point that encapsulates the underlying implementation details, promoting loose coupling and easier switching of inner implementations.</p>
<pre class="language-php"><code>interface Logger
{
	public function log(string $text): void;
}

class FileLogger implements Logger
{
	public function log(string $text): void
	{
		// log to a file
	}
}

class DatabaseLogger implements Logger
{
	public function log(string $text): void
	{
		// log to a database
	}
}

class Log
{
	public static function info(string $logger, string $text): void
	{
		(new $logger)-&gt;log($text);
	}
}

Log::info(DatabaseLogger::class, 'hello');</code></pre>
<div>
<h2>Strategy Pattern</h2>
<div>
<div>A way to switch implementations (strategies) for objects that perform the same actions differently.</div>
<ul>
<li>When some action could be done in different ways, for example payment can be processed by different payment providers.</li>
<li>When passing a bunch of flags to a function as parameter to configure different behaviors just pass a different behavior (strategy).</li>
</ul>
<div>
<pre class="language-php"><code>interface PaymentStrategyInterface
{
	public function doPayment($amount): void;
}

class PaymentService
{
	public function __construct(private PaymentStrategyInterface $strategy) {}

	public function process(int $amount): void
	{
		$this-&gt;strategy-&gt;doPayment($amount);
	}
}

class CreditCardPaymentStrategy implements PaymentStrategyInterface
{
	public function doPayment($amount): void
	{
		// do credit card stuff
	}
}

class PaypalPaymentStrategy implements PaymentStrategyInterface
{
	public function doPayment($amount): void
	{
		// do paypal stuff
	}
}

$ccStrategy = new CreditCardPaymentStrategy();
$paypalStrategy = new PaypalPaymentStrategy();

// pass in whichever
$paymentService = new PaymentService($ccStrategy);

// OR you can create Context, which encapsulates currently selected strategy

class PaymentStrategyContext
{
	private PaymentStrategyInterface $strategy;

	public function __construct(string $paymentMethod)
	{
		$this-&gt;strategy = match ($paymentMethod) {
			'paypal' =&gt; new PaypalPaymentStrategy(),
			'credit_card' =&gt; new CreditCardPaymentStrategy(),
			default =&gt; throw new \InvalidArgumentException('Unknown payment method'),
		};
	}

	public function doPayment($amount)
	{
		return $this-&gt;strategy-&gt;doPayment($amount);
	}
}

$strategyService = new PaymentStrategyContext($request-&gt;payment_method);
$strategyService-&gt;doPayment($amount);</code></pre>
<div>
<h2>Builder Pattern</h2>
<p class="whitespace-pre-wrap break-words">The Builder pattern provides a flexible and readable way to construct complex objects step by step, separating the construction of a complex object from its representation. It allows you to create different variations of an object using the same construction process, which is particularly useful when an object has multiple optional parameters or configuration possibilities.</p>
<ul class="-mt-1 [li&gt;&amp;]:mt-2 list-disc space-y-2 pl-8">
<li class="whitespace-normal break-words">Creating objects with numerous constructor parameters</li>
<li class="whitespace-normal break-words">Implementing configurable object creation where the configuration may evolve</li>
<li class="whitespace-normal break-words">Providing a clean, fluent interface for object initialization</li>
<li class="whitespace-normal break-words">Ensuring consistent object creation across different configurations</li>
</ul>
<pre class="language-php"><code>class Book
{
	private $id;
	private $title;
	private $price;
	private $author;

	public function __construct(BookBuilder $builder)
	{
		$this-&gt;id = $builder-&gt;getId();
		$this-&gt;title = $builder-&gt;getTitle();
		$this-&gt;price = $builder-&gt;getPrice();
		$this-&gt;author = $builder-&gt;getAuthor();
	}
}

class BookBuilder
{
	private $id;
	private $title;
	private $price;
	private $author;

	public function setId($id): self
	{
		$this-&gt;id = $id;
		return $this;
	}

	public function setTitle($title): self
	{
		$this-&gt;title = $title;
		return $this;
	}

	public function setPrice($price): self
	{
		$this-&gt;price = $price;
		return $this;
	}

	public function setAuthor($author): self
	{
		$this-&gt;author = $author;
		return $this;
	}

	public function build()
	{
		if (empty($this-&gt;id) || empty($this-&gt;title) || empty($this-&gt;price)  || empty($this-&gt;author)) {
			throw new \Exception('Required fields missing');
		}

		return new Book($this);
	}
}

$productBuilder = new BookBuilder();
$product = $productBuilder
	-&gt;setId(101)
	-&gt;setTitle('Title')
	-&gt;setPrice(123.99)
	-&gt;setAuthor('author')
	-&gt;build();</code></pre>
<div>
<h2>Factory Pattern</h2>
<p>Uniform way to create objects in one step. Factory is about "what" type of object to create.</p>
<pre class="language-php"><code>interface Animal
{
	public function speak(): string;
}

class Dog implements Animal
{
	public function speak(): string
	{
		return 'Woof!';
	}
}

class Cat implements Animal
{
	public function speak(): string
	{
		return 'Meow!';
	}
}

class AnimalFactory
{
	public function createAnimal(string $type): Animal
	{
		return match ($type) {
			'dog' =&gt; new Dog(),
			'cat' =&gt; new Cat(),
			default =&gt; throw new \Exception('Unknown animal')
		};
	}
}

// Example usage
$factory = new AnimalFactory();
$dog = $factory-&gt;createAnimal('dog');
echo $dog-&gt;speak(); </code></pre>
<div>
<h2>Adapter Pattern</h2>
<p>The Adapter pattern allows incompatible interfaces to work together by creating a wrapper that converts the interface of one class into another interface that clients expect. It enables seamless integration between classes with different interfaces, allowing you to make existing classes work with others without modifying their source code. This pattern is particularly useful when migrating between libraries, integrating third-party components, or bridging legacy and modern systems.</p>
<pre class="language-php"><code>// target interface
interface BookInterface
{
	public function read();
}

// existing class with an incompatible interface
class EBook
{
	public function displayContent()
	{
		echo 'Displaying e-book content';
	}
}

class EBookAdapter implements BookInterface
{
	private $eBook;

	public function __construct(EBook $eBook)
	{
		$this-&gt;eBook = $eBook;
	}

	public function read()
	{
		$this-&gt;eBook-&gt;displayContent();
	}
}

class Library
{
	public function readBook(BookInterface $book)
	{
		$book-&gt;read();
	}
}

// Usage
$eBook = new EBook();
$eBookAdapter = new EBookAdapter($eBook);

$library = new Library();
$library-&gt;readBook($eBookAdapter);</code></pre>
<div>
<h2>Decorator Pattern</h2>
<p>The Decorator pattern dynamically adds behaviors to an object by wrapping it with additional functionality, allowing flexible and granular extension without inheritance. It enables runtime modification of individual objects' capabilities without affecting other instances of the same class.</p>
<pre class="language-php"><code>interface Pie
{
	public function makePie(): string;
	public function getPrice(): int;
}

class BasicPie implements Pie
{
	private const PRICE = 1;

	public function makePie(): string
	{
		return 'basic pie';
	}

	public function getPrice(): int
	{
		return self::PRICE;
	}
}

abstract class BasicPieDecorator implements Pie
{
	public function __construct(protected Pie $basicPie) {}

	abstract public function makePie(): string;
	abstract public function getPrice(): int;
}

class ApplePie extends BasicPieDecorator
{
	private const PRICE = 2;

	public function makePie(): string
	{
		return 'apple pie';
	}

	public function getPrice(): int
	{
		return $this-&gt;basicPie-&gt;getPrice() + self::PRICE;
	}
}

class PumpkinPie extends BasicPieDecorator
{
	private const PRICE = 3;

	public function makePie(): string
	{
		return 'pumpkin pie';
	}

	public function getPrice(): int
	{
		return $this-&gt;basicPie-&gt;getPrice() + self::PRICE;
	}
}

$basicPie = new BasicPie();
$basicPie-&gt;getPrice();

$applePie = new ApplePie($basicPie);
$applePie-&gt;getPrice();

$pumpkinPie = new PumpkinPie($basicPie);
$pumpkinPie-&gt;getPrice();</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Lesser Known Design Patterns</title>
        <author>
            <name>Enxas</name>
        </author>
        <link href="https://phpmemo.com/lesser-known-design-patterns.html"/>
        <id>https://phpmemo.com/lesser-known-design-patterns.html</id>
            <category term="PHP"/>
            <category term="Laravel"/>
            <category term="Design Patterns"/>

        <updated>2024-12-07T17:59:40+02:00</updated>
            <summary>
                <![CDATA[
                    There are numerous lesser-known patterns that can significantly enhance your system design. This blog post will delve into some of them. The Laravel Pipeline pattern&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>There are numerous lesser-known patterns that can significantly enhance your system design. This blog post will delve into some of them.</p>
<h2>Pipeline Pattern</h2>
<p>The Laravel Pipeline pattern allows for a sequence of tasks or processes to be passed through a series of filters or pipes, each with a single responsibility, enhancing flexibility, testability, and extensibility.</p>
<pre class="language-php"><code>interface PipeInterface
{
	public function handle($passable, Closure $next);
}

class VerifyUserAge implements PipeInterface
{
	public function handle($user, Closure $next)
	{
		// Skip this pipe if user is admin
		if ($user-&gt;isAdmin()) {
			return $next($user);
		}

		if ($user-&gt;age &lt; 18) {
			throw new \Exception("User is not old enough");
		}
		return $next($user);
	}
}

class ValidateUserEmail implements PipeInterface
{
	public function handle($user, Closure $next)
	{
		if (!filter_var($user-&gt;email, FILTER_VALIDATE_EMAIL)) {
			throw new \Exception("Invalid email format");
		}
		return $next($user);
	}
}

class NormalizeUserName implements PipeInterface
{
	public function handle($user, Closure $next)
	{
		$user-&gt;name = trim(ucwords(strtolower($user-&gt;name)));
		return $next($user);
	}
}

class ProcessByType implements PipeInterface
{
	public function __construct(private string $type) {}

	public function handle($data, Closure $next)
	{
		match ($this-&gt;type) {
			'premium' =&gt; $this-&gt;processPremiumUser($data),
			'standard' =&gt; $this-&gt;processStandardUser($data),
			default =&gt; null
		};

		return $next($data);
	}
}

// User registration pipeline
class UserRegistrationPipeline
{
	public function process($user)
	{
		$pipes = [
			VerifyUserAge::class,
			ValidateUserEmail::class,
			NormalizeUserName::class,
			new ProcessByType('premium'),
		];

		return app(\Illuminate\Pipeline\Pipeline::class)
			-&gt;send($user)
			-&gt;through($pipes)
			-&gt;thenReturn();
	}
}

// Usage example
class UserController
{
	protected $pipeline;

	public function __construct(UserRegistrationPipeline $pipeline)
	{
		$this-&gt;pipeline = $pipeline;
	}

	public function register(Request $request)
	{
		try {
			$user = $this-&gt;pipeline-&gt;process(new User($request-&gt;all()));
			// Save user if all pipes pass
			$user-&gt;save();
			return response()-&gt;json(['message' =&gt; 'User registered successfully']);
		} catch (\Exception $e) {
			return response()-&gt;json(['error' =&gt; $e-&gt;getMessage()], 400);
		}
	}
}</code></pre>
<h2>Tap pattern</h2>
<p>The <code>tap</code> function takes two arguments: the first is the value to be passed, and the second is a closure. This closure receives the value, performs some operations on it, and then returns it.</p>
<pre class="language-php"><code>// instead of doing this
$article = Article::findOrFail($id);
$article-&gt;incrementViews();
$article-&gt;doSomething();

return $article;


// we can keep related functionality to one block of code
return tap(Article::findOrFail($id), function (Article $article) {
	$article-&gt;incrementViews();
	$article-&gt;doSomething();
});</code></pre>
<p>The <code>update</code> method typically returns a boolean value. However, by using the <code>tap</code> function, the <code>update</code> method instead returns the User model that was tapped. This functionality of <code>tap</code> makes it simple to ensure any method on an object returns the object itself.</p>
<pre class="language-php"><code>return tap($user)-&gt;update(['email' =&gt; $email]);</code></pre>
<p><a href="https://medium.com/@tanmaymishu/the-anatomy-of-laravels-tap-function-ea239c9846ab" target="_blank" rel="noopener noreferrer">The anatomy of Laravel’s tap() function</a></p>
<h2><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit;">Cache Refresh Ahead Pattern</span></h2>
<p>This pattern ensures that the cache is updated before it expires, guaranteeing that users receive fresh data at all times. If the data is frequently accessed, it will always be cached.</p>
<pre class="language-php"><code>function cacheWithRefreshAhead(string $key, int $ttl, float $refreshAheadTime, \Closure $callback): mixed
{
	$cachedData = Cache::get($key);

	if ($cachedData) {
		$expiresAt = Cache::get("$key:expires_at");

		if ($expiresAt &amp;&amp; Carbon::now()-&gt;diffInMinutes($expiresAt) &lt;= $ttl * $refreshAheadTime) {
			// dispatch a Job to update cache:
			Cache::put($key, $callback(), $ttl);
			Cache::put("$key:expires_at", Carbon::now()-&gt;addMinutes($ttl), $ttl);
		}

		return $cachedData;
	}

	// Cache miss, so cache it
	$data = $callback();
	// dispatch a Job to update cache:
	Cache::put($key, $data, $ttl);
	Cache::put("$key:expires_at", Carbon::now()-&gt;addMinutes($ttl), $ttl);

	return $data;
}

// Usage example 
$data = cacheWithRefreshAhead('some-key', 30, 0.7, function () {
	// Retrieve fresh data
	return ['data' =&gt; 123];
});</code></pre>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Troubleshooting PHP JIT: A Definitive Guide to Enabling Performance Boost When Configuration Fails</title>
        <author>
            <name>Enxas</name>
        </author>
        <link href="https://phpmemo.com/troubleshooting-php-jit-a-definitive-guide-to-enabling-performance-boost-when-configuration-fails.html"/>
        <id>https://phpmemo.com/troubleshooting-php-jit-a-definitive-guide-to-enabling-performance-boost-when-configuration-fails.html</id>
            <category term="PHP"/>
            <category term="Laravel"/>
            <category term="JIT"/>
            <category term="Docker"/>

        <updated>2024-11-30T18:18:37+02:00</updated>
            <summary>
                <![CDATA[
                    Many posts online suggest that enabling PHP JIT is as simple as adding some values to the php.ini file, but that's not exactly the case.
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Many posts online suggest that enabling PHP JIT is as simple as adding some values to the <strong>php.ini</strong> file, but that's not exactly the case. Sometimes adding these configuration values doesn't seem to do anything. In this post, I'll show how to enable PHP JIT when nothing seems to work. I'll use a default Laravel Sail Docker container, but the idea is the same for any server running PHP.</p>
<p>1. Check if a PHP extension is blocking JIT from loading. Type this command in the terminal to see JIT status:</p>
<pre class="language-bash"><code>./vendor/bin/sail php -r "print_r(opcache_get_status(false)['jit']);"</code></pre>
<p class="whitespace-pre-wrap break-words">If you see this warning, then a PHP extension is blocking JIT:</p>
<blockquote>
<p>PHP Warning: JIT is incompatible with third-party extensions that override zend_execute_ex(). JIT disabled. in Unknown on line 0.</p>
</blockquote>
<p>2. Disable problematic extensions. Laravel Sail Docker file installs many extensions, so we need to identify which ones are not compatible with PHP JIT. After disabling extensions one by one, I found that <strong>php8.3-pcov</strong> and <strong>php8.3-xdebug</strong> are problematic.</p>
<p class="whitespace-pre-wrap break-words">To disable these extensions:</p>
<ul class="-mt-1 [li&gt;&amp;]:mt-2 list-disc space-y-2 pl-8">
<li class="whitespace-normal break-words">Ensure your .env file doesn't have <strong>SAIL_XDEBUG_MODE</strong> or any other environmental values that enable xDebug</li>
<li class="whitespace-normal break-words">Add these values to your php.ini:</li>
</ul>
<pre class="language-bash"><code>pcov.enabled=0
xdebug.mode=off</code></pre>
<p>Also, add these values to enable JIT:</p>
<pre class="language-bash"><code>[opcache]
zend_extension=opcache.so
opcache.enable=1
opcache.enable_cli=1
opcache.memory_consumption=128M
opcache.interned_strings_buffer=8
opcache.max_accelerated_files=4000
opcache.revalidate_freq=60
opcache.fast_shutdown=1
opcache.jit_buffer_size=100M
opcache.jit=tracing</code></pre>
<p>3. <span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">Restart If you're using Laravel Sail, rebuild your image with:</span></p>
<ul class="-mt-1 [li&gt;&amp;]:mt-2 list-disc space-y-2 pl-8">
<li class="whitespace-normal break-words"><code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.3rem] px-1 py-px text-[0.9rem]">sail down</code></li>
<li class="whitespace-normal break-words"><code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.3rem] px-1 py-px text-[0.9rem]">sail build</code></li>
<li class="whitespace-normal break-words"><code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.3rem] px-1 py-px text-[0.9rem]">sail up -d</code></li>
</ul>
<p class="whitespace-pre-wrap break-words">Execute the command again to verify if JIT is properly enabled:</p>
<pre class="language-bash"><code>./vendor/bin/sail php -r "print_r(opcache_get_status(false)['jit']);"</code></pre>
<p>And that's it. Hopefully, your PHP JIT is now enabled and working.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Setting up Laravel Dusk for Laravel Sail Project with Decoupled Vue Frontend on Windows</title>
        <author>
            <name>Enxas</name>
        </author>
        <link href="https://phpmemo.com/setting-up-laravel-dusk-for-laravel-sail-project-with-decoupled-vue-frontend-on-windows-2.html"/>
        <id>https://phpmemo.com/setting-up-laravel-dusk-for-laravel-sail-project-with-decoupled-vue-frontend-on-windows-2.html</id>
            <category term="WSL"/>
            <category term="Vue"/>
            <category term="Testing"/>
            <category term="Laravel"/>
            <category term="Dusk"/>
            <category term="Docker"/>

        <updated>2024-11-17T14:06:12+02:00</updated>
            <summary>
                <![CDATA[
                    Requirements Laravel Sail project Vue project with Vite WSL Installation Steps 1. In your docker-compose.yml file, add these ports to the "selenium" section: ports: -&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <div>
<h2 class="font-600 text-xl font-bold">Requirements</h2>
<ul class="-mt-1 [li&gt;&amp;]:mt-2 list-disc space-y-2 pl-8">
<li class="whitespace-normal break-words">Laravel Sail project</li>
<li class="whitespace-normal break-words">Vue project with Vite</li>
<li class="whitespace-normal break-words">WSL</li>
</ul>
</div>
<div>
<h2 class="font-600 text-xl font-bold">Installation Steps<br><br></h2>
1. In your <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.3rem] px-1 py-px text-[0.9rem]">docker-compose.yml</code> file, add these ports to the "selenium" section:</div>
<div>
<pre class="language-yaml"><code>ports:
    - '${FORWARD_SELENIUM_PORT:-4444}:4444'
    - '${FORWARD_SELENIUM_HEADFUL_PORT:-7900}:7900'</code></pre>
</div>
<div>2. Install Dusk:</div>
<div>
<pre class="language-bash"><code>sail composer require --dev laravel/dusk</code></pre>
<p>3. Create Dusk test and update configuration:</p>
<pre class="language-bash"><code>sail artisan dusk:install</code></pre>
<p> 4. Create a test:</p>
<pre class="language-bash"><code>sail artisan dusk:make LoginTest</code></pre>
<p> 5. Add this test method to verify functionality:</p>
<pre class="language-php"><code>public function testLogin(): void
{
    $this-&gt;browse(function (Browser $browser) {
        $browser-&gt;visit('/')
            -&gt;type('name', 'Josh')
            -&gt;type('email', 'josh@example.com')
            -&gt;type('password', 'hunter2')
            -&gt;press('Login')
            -&gt;waitForText('Logged In');
    });
}</code></pre>
<h2 class="font-600 text-xl font-bold">Configuration<br><br></h2>
<p>Before running tests, ensure your Vue application running on Windows is accessible from within the Laravel Sail Docker container.<br><br></p>
</div>
<div>1. Host your Vue application with:
<pre class="language-bash"><code>npm run dev -- --host</code></pre>
<p> 2. Create <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.3rem] px-1 py-px text-[0.9rem]">.env.dusk</code> file in your Laravel application root with these values:</p>
<pre class="language-bash"><code>APP_URL=http://192.168.0.100:5174/
DB_DATABASE=test_db
LARAVEL_SAIL=1</code></pre>
<p> (Replace IP address with your hosted Vue application IP address).</p>
</div>
<div>
<h2 class="font-600 text-xl font-bold">Running Tests<br><br></h2>
<p class="whitespace-pre-wrap break-words">Basic test execution:</p>
</div>
<div>
<pre class="language-bash"><code>sail dusk --env=.env.dusk</code></pre>
</div>
<div>
<p>To view tests running visually:<br><br></p>
1. Add to <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.3rem] px-1 py-px text-[0.9rem]">.env.dusk</code>:</div>
<div>
<pre class="language-bash"><code>DUSK_HEADLESS_DISABLED=1</code></pre>
</div>
<div>2. Visit <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.3rem] px-1 py-px text-[0.9rem]">http://localhost:7900</code> (default password: 'secret')<br>
<p class="whitespace-pre-wrap break-words">Optionally, you can provide a custom PHPUnit configuration:</p>
</div>
<div>
<pre class="language-bash"><code>sail dusk --configuration phpunit.dusk.xml</code></pre>
</div>
<div>
<div class="relative flex flex-col rounded-lg">
<div class="pointer-events-none sticky my-0.5 ml-0.5 flex items-center justify-end px-1.5 py-1 mix-blend-luminosity top-0">
<div class="from-bg-300/90 to-bg-300/70 pointer-events-auto rounded-md bg-gradient-to-b p-0.5 backdrop-blur-md"> </div>
</div>
</div>
</div>
            ]]>
        </content>
    </entry>
</feed>
